const express = require('express');
const cors = require('cors');
const { createClient } = require('@supabase/supabase-js');
const OpenAI = require('openai');
const axios = require('axios');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3000;

// Inicializar Supabase
const supabase = createClient(
  'https://nbcmqhygbbwjmjwajacm.supabase.co',
  'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5iY21xaHlnYmJ3am1qd2FqYWNtIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTEwNDE4MjgsImV4cCI6MjA2NjYxNzgyOH0.ZOObCiyZD-glxXWp08a-0kBve7aJzAIFcfCOd-38h_Y'
);

// Inicializar OpenAI
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

// Middlewares
app.use(cors());
app.use(express.json());

// Fun√ß√£o para buscar usu√°rio no banco
async function buscarUsuario(telefone) {
  try {
    const { data: usuario, error } = await supabase
      .from('usuarios')
      .select('*')
      .eq('telefone', telefone)
      .single();
    
    if (error && error.code !== 'PGRST116') {
      console.error('‚ùå Erro ao buscar usu√°rio:', error);
      return null;
    }
    
    return usuario;
  } catch (error) {
    console.error('‚ùå Erro ao buscar usu√°rio:', error);
    return null;
  }
}

// Fun√ß√£o para salvar usu√°rio no banco
async function salvarUsuario(telefone, nome, profissao, especialidade) {
  try {
    const { data, error } = await supabase
      .from('usuarios')
      .insert({
        telefone: telefone,
        nome: nome,
        profissao: profissao,
        especialidade: especialidade,
        status: 'ativo',
        created_at: new Date()
      })
      .select()
      .single();
    
    if (error) {
      console.error('‚ùå Erro ao salvar usu√°rio:', error);
      return null;
    }
    
    console.log('‚úÖ Usu√°rio salvo:', data);
    return data;
  } catch (error) {
    console.error('‚ùå Erro ao salvar usu√°rio:', error);
    return null;
  }
}

// Fun√ß√£o para extrair dados de forma mais flex√≠vel
function extrairDadosCompletos(mensagem) {
  console.log('üîç Tentando extrair dados de:', mensagem);
  
  // Buscar padr√µes mais espec√≠ficos para nome
  const regexNomeCompleto = /(?:me chamo|meu nome √©|sou )?([A-Za-z√Ä-√ø\s]{2,20})(?:\s+e\s+sou|\s+sou|\s*,)/i;
  const matchCompleto = mensagem.match(regexNomeCompleto);
  
  if (matchCompleto) {
    console.log('‚úÖ Nome e profiss√£o encontrados:', matchCompleto[1]);
    return {
      nome: matchCompleto[1].trim(),
      temNome: true,
      temProfissao: true,
      profissao: mensagem.replace(regexNomeCompleto, '').replace(/sou\s*/i, '').trim()
    };
  }
  
  // Buscar s√≥ nome simples
  const regexNome = /(?:me chamo|meu nome √©|sou |eu sou )?([A-Za-z√Ä-√ø]{2,20})(?:\s|$|,|\.)/i;
  const matchNome = mensagem.match(regexNome);
  
  if (matchNome && !mensagem.toLowerCase().includes('sou') && !mensagem.toLowerCase().includes('trabalho')) {
    console.log('‚úÖ S√≥ nome encontrado:', matchNome[1]);
    return {
      nome: matchNome[1].trim(),
      temNome: true
    };
  }
  
  console.log('‚ùå Nenhum nome claro encontrado');
  return {};
}

// Sistema de conversa por etapas - VERS√ÉO LUKE STORIES
async function processarConversaEtapas(telefone, mensagem) {
  console.log('üß† Processando conversa Luke Stories...');
  
  // Buscar usu√°rio
  let usuario = await buscarUsuario(telefone);
  console.log('üë§ Usu√°rio encontrado:', usuario ? `${usuario.nome || 'Sem nome'} (status: ${usuario.status})` : 'Nenhum');
  
  // Verificar se usu√°rio pagou
  if (!usuario || usuario.status !== 'pago') {
    return `üîí *Acesso restrito!*

Para usar o Luke Stories, voc√™ precisa adquirir o acesso primeiro.

üí≥ *Fa√ßa seu pagamento em:* 
https://payment.ticto.app/O6D37000C

Ap√≥s o pagamento, voc√™ receber√° acesso imediato! ‚ú®`;
  }
  
  // Usu√°rio tem perfil completo
  if (usuario.nome && usuario.profissao && usuario.especialidade) {
    console.log(`‚úÖ Usu√°rio completo: ${usuario.nome}`);
    
    // Verificar se quer alterar informa√ß√µes
    if (mensagem.toLowerCase().includes('alterar') || mensagem.toLowerCase().includes('mudar') || mensagem.toLowerCase().includes('trocar')) {
      return `Oi ${usuario.nome}! üòä

Quer alterar suas informa√ß√µes?

üìã *Dados atuais:*
üë§ **Nome:** ${usuario.nome}
üíº **Profiss√£o:** ${usuario.profissao}
üéØ **Especialidade:** ${usuario.especialidade}
üè¢ **Empresa:** ${usuario.empresa || 'N√£o informada'}

üîÑ *Me diga o que quer alterar:*
Ex: "Meu nome agora √©...", "Mudei de especialidade para...", etc.`;
    }
    
    // Gerar texto personalizado baseado na solicita√ß√£o
    return await gerarTextoPersonalizado(usuario, mensagem);
  }
  
  // Usu√°rio incompleto - coletar dados por etapas
  if (!usuario.nome) {
    // Tentar extrair nome da mensagem
    const nomeExtraido = extrairNome(mensagem);
    
    if (nomeExtraido) {
      await supabase.from('usuarios')
        .update({ nome: nomeExtraido })
        .eq('telefone', telefone);
      
      return `Prazer te conhecer, ${nomeExtraido}! üòä

üéØ *Agora me conte:*
Qual sua **profiss√£o e especialidade**?

üí° *Pode ser qualquer √°rea:*
üó£Ô∏è "Sou [sua profiss√£o], especialista em [especialidade]"
üó£Ô∏è "Trabalho como [profiss√£o] focado em [√°rea]"
üó£Ô∏è "Atuo na √°rea de [sua profiss√£o]"

Pode falar do seu jeito! üí¨`;
    }
    
    return `üëã *Oi! Sou o Luke Stories!*

Para personalizar meus textos para voc√™, preciso te conhecer melhor.

üéØ *Como gostaria de ser chamado(a)?*

Pode mandar por √°udio ou texto! üòä`;
  }
  
  if (!usuario.profissao) {
    // Extrair profiss√£o e especialidade
    const dadosProfissionais = extrairProfissaoEspecialidade(mensagem);
    
    await supabase.from('usuarios')
      .update({ 
        profissao: dadosProfissionais.profissao,
        especialidade: dadosProfissionais.especialidade
      })
      .eq('telefone', telefone);
    
    return `Excelente, ${usuario.nome}! üëè

üìã *Registrei:*
üíº **Profiss√£o:** ${dadosProfissionais.profissao}
üéØ **Especialidade:** ${dadosProfissionais.especialidade}

üè¢ *√öltima pergunta:* Voc√™ tem empresa/neg√≥cio? Qual o nome?

Se n√£o tiver, pode falar "n√£o tenho empresa" üòä`;
  }
  
  if (!usuario.empresa) {
    // Salvar empresa
    const empresa = mensagem.toLowerCase().includes('n√£o') || mensagem.toLowerCase().includes('nao') ? 
      'Profissional aut√¥nomo' : mensagem.trim();
    
    await supabase.from('usuarios')
      .update({ 
        empresa: empresa,
        status: 'ativo_completo'
      })
      .eq('telefone', telefone);
    
    return `üéâ *Perfeito, ${usuario.nome}!*

Agora tenho tudo que preciso:
üë§ **Nome:** ${usuario.nome}
üíº **Profiss√£o:** ${usuario.profissao}
üéØ **Especialidade:** ${usuario.especialidade}
üè¢ **Empresa:** ${empresa}

üöÄ *AGORA ESTAMOS PRONTOS!*

üí¨ *Como usar:*
üì± "Preciso de um texto animado para gravar em casa"
üõçÔ∏è "Estou no consult√≥rio, quero uma dica sobre [assunto]"
üéØ "Quero algo promocional para meus servi√ßos"

*Pode mandar por √°udio!* üé§

‚ú® *Vamos come√ßar? Me mande sua primeira solicita√ß√£o!* ‚ú®`;
  }
  
  return "Algo deu errado, pode tentar novamente?";
}

// FUN√á√ÉO CORRIGIDA - Extrair nome sem confundir com profiss√£o
function extrairNome(mensagem) {
  console.log('üîç Extraindo nome de:', mensagem);
  
  // Se mensagem come√ßa com padr√µes de profiss√£o, N√ÉO extrair nome
  const padroesProfissao = [
    /^sou\s+[a-zA-Z√Ä-√ø]+/i,
    /^trabalho\s+(como|com|de)/i,
    /^atuo\s+(como|na|no)/i,
    /^formado\s+em/i,
    /especialista\s+em/i,
    /^minha\s+profiss√£o/i,
    /^√°rea\s+de/i
  ];
  
  // Verificar se √© profiss√£o
  const eProfissao = padroesProfissao.some(padrao => padrao.test(mensagem));
  if (eProfissao) {
    console.log('‚ùå Detectado como profiss√£o, n√£o extraindo nome');
    return null;
  }
  
  // Padr√µes para nomes (sua l√≥gica original mantida)
  const padroes = [
    /(?:me chamo|meu nome √©|sou |eu sou )\s*([A-Za-z√Ä-√ø\s]{2,30})$/i,
    /^([A-Za-z√Ä-√ø\s]{2,30})$/i // Nome sozinho
  ];
  
  for (const padrao of padroes) {
    const match = mensagem.match(padrao);
    if (match && !mensagem.toLowerCase().includes('profiss') && !mensagem.toLowerCase().includes('trabalho')) {
      const nome = match[1].trim();
      console.log('‚úÖ Nome extra√≠do:', nome);
      return nome;
    }
  }
  
  console.log('‚ùå Nenhum nome encontrado');
  return null;
}

// FUN√á√ÉO MELHORADA - Extrair profiss√£o e especialidade universal
function extrairProfissaoEspecialidade(mensagem) {
  console.log('üîç Extraindo profiss√£o de:', mensagem);
  
  let profissao = mensagem;
  let especialidade = null;
  
  // Remover prefixos comuns (mantendo sua l√≥gica)
  profissao = profissao.replace(/^(sou |trabalho como |atuo como |me formei em |formado em |especialista em |√°rea de )/i, '');
  
  // Buscar padr√µes de especialidade (expandindo sua regex)
  const regexEspecialidade = /(.*?)(?:,|\s+)(?:especialista em|especialidade em|trabalho com|foco em|√°rea de|focado em|focada em|especializado em|especializada em|que trabalha com)\s+(.+)/i;
  const match = mensagem.match(regexEspecialidade);
  
  if (match) {
    profissao = match[1].trim();
    especialidade = match[2].trim();
  } else {
    // Se n√£o tem especialidade clara, usar "Geral"
    especialidade = 'Geral';
  }
  
  console.log(`‚úÖ Profiss√£o: "${profissao}" | Especialidade: "${especialidade}"`);
  
  return {
    profissao: profissao,
    especialidade: especialidade
  };
}

// Fun√ß√£o para gerar texto personalizado
async function gerarTextoPersonalizado(usuario, solicitacao) {
  console.log(`üéØ Gerando texto para ${usuario.nome}: ${solicitacao}`);
  
  const prompt = `Voc√™ √© o Luke Stories, assistente pessoal para cria√ß√£o de textos para stories e conte√∫do.

DADOS DO USU√ÅRIO:
- Nome: ${usuario.nome}
- Profiss√£o: ${usuario.profissao}
- Especialidade: ${usuario.especialidade}
- Empresa: ${usuario.empresa || 'Profissional aut√¥nomo'}

SOLICITA√á√ÉO: ${solicitacao}

INSTRU√á√ïES:
1. Crie um texto curto (m√°ximo 150 palavras) para o usu√°rio gravar
2. Use o nome da pessoa no texto
3. Adapte o tom conforme a solicita√ß√£o (animado, profissional, motivacional, etc.)
4. Inclua call-to-action sutil relacionado √† profiss√£o
5. Seja natural e conversacional
6. Se for uma dica, seja espec√≠fico da √°rea de especialidade

FORMATO DA RESPOSTA:
{
  "texto_para_gravar": "texto que o usu√°rio vai gravar",
  "dicas_gravacao": "dicas de como gravar (tom, gestos, etc.)",
  "hashtags": ["#hashtag1", "#hashtag2", "#hashtag3"]
}

Responda APENAS com o JSON v√°lido.`;

  try {
    const completion = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [{ role: "user", content: prompt }],
      max_tokens: 400
    });

    const resultado = JSON.parse(completion.choices[0].message.content);
    
    // Salvar intera√ß√£o no hist√≥rico
    await supabase.from('conversas').insert({
      telefone: usuario.telefone,
      usuario_id: usuario.id,
      mensagem_usuario: solicitacao,
      resposta_bot: JSON.stringify(resultado),
      created_at: new Date()
    });
    
    return `üé¨ *Seu texto personalizado, ${usuario.nome}!*

üì± **TEXTO PARA GRAVAR:**
"${resultado.texto_para_gravar}"

üé≠ **DICAS DE GRAVA√á√ÉO:**
${resultado.dicas_gravacao}

üè∑Ô∏è **HASHTAGS:**
${resultado.hashtags.join(' ')}

---
üìã *Para copiar:* Mantenha pressionado o texto acima

‚ú® *Precisa de outro texto? S√≥ me falar!* ‚ú®`;

  } catch (error) {
    console.error('‚ùå Erro ao gerar texto personalizado:', error);
    
    return `üé¨ *Texto para voc√™, ${usuario.nome}!*

üì± **TEXTO PARA GRAVAR:**
"Oi, eu sou ${usuario.nome}! Como ${usuario.profissao} especialista em ${usuario.especialidade}, estou aqui para te ajudar com o que voc√™ precisar. ${usuario.empresa !== 'Profissional aut√¥nomo' ? `Aqui na ${usuario.empresa}` : 'No meu trabalho'}, eu fa√ßo quest√£o de dar o meu melhor para voc√™. Vem conversar comigo!"

üé≠ **DICA:** Grave com energia e sorria!

üè∑Ô∏è **HASHTAGS:** #${usuario.profissao.replace(/\s/g, '')} #${usuario.especialidade.replace(/\s/g, '')} #profissional

---
‚ú® *Precisa de outro texto? S√≥ me falar!* ‚ú®`;
  }
}

// Fun√ß√£o para obter exemplos de especialidade por profiss√£o
function getExemplosEspecialidade(profissao) {
  const exemplos = {
    'barbeiro': 'fade, barba, cortes cl√°ssicos, degrad√™, bigode',
    'dentista': 'ortodontia, implantes, clareamento, est√©tica dental',
    'cabeleireira': 'cortes femininos, colora√ß√£o, escova, cachos, alisamento',
    'nutricionista': 'emagrecimento, esportiva, infantil, gestante, vegana',
    'esteticista': 'limpeza de pele, massagem, depila√ß√£o, drenagem, peeling',
    'mec√¢nico': 'motor, freios, suspens√£o, el√©trica, geral',
    'manicure': 'unhas decoradas, pedicure, alongamento, nail art',
    'personal trainer': 'muscula√ß√£o, funcional, emagrecimento, idosos',
    'm√©dico': 'cl√≠nica geral, cardiologia, pediatria, ginecologia',
    'advogado': 'civil, criminal, trabalhista, fam√≠lia, empresarial'
  };
  
  return exemplos[profissao.toLowerCase()] || 'sua √°rea principal de atua√ß√£o';
}

// Fun√ß√£o para processar √°udio com Whisper
async function processarAudio(audioUrl) {
  try {
    console.log('üéµ Baixando √°udio:', audioUrl);
    console.log('üïê In√≠cio download:', new Date().toISOString());
    
    const audioResponse = await axios.get(audioUrl, {
      responseType: 'arraybuffer',
      timeout: 10000
    });
    
    console.log('‚úÖ √Åudio baixado!');
    console.log('üìä Tamanho do arquivo:', audioResponse.data.byteLength, 'bytes');
    console.log('üïê Fim download:', new Date().toISOString());
    
    console.log('üéµ Enviando para OpenAI Whisper...');
    console.log('üïê In√≠cio Whisper:', new Date().toISOString());
    
    const fs = require('fs');
    const path = require('path');
    const tempPath = path.join('/tmp', `audio_${Date.now()}.ogg`);
    
    fs.writeFileSync(tempPath, Buffer.from(audioResponse.data));
    console.log('üìÅ Arquivo salvo em:', tempPath);
    
    const audioStream = fs.createReadStream(tempPath);
    
    const transcription = await openai.audio.transcriptions.create({
      file: audioStream,
      model: 'whisper-1',
      language: 'pt'
    });
    
    fs.unlinkSync(tempPath);
    console.log('üóëÔ∏è Arquivo tempor√°rio removido');
    
    console.log('üïê Fim Whisper:', new Date().toISOString());
    console.log('‚úÖ Texto transcrito:', transcription.text);
    return transcription.text;
  } catch (error) {
    console.log('üïê Erro em:', new Date().toISOString());
    console.error('‚ùå Erro detalhado:', {
      message: error.message,
      code: error.code,
      status: error.status
    });
    return null;
  }
}

// Rota de teste
app.get('/', (req, res) => {
  res.json({ 
    message: 'Bot Stories API funcionando!',
    status: 'online',
    timestamp: new Date().toISOString(),
    supabase: 'conectado',
    openai: 'configurado'
  });
});

// Teste simples do banco
app.get('/test-simple', async (req, res) => {
  try {
    const { data, error } = await supabase
      .from('usuarios')
      .select('id')
      .limit(1);
    
    res.json({ 
      message: 'Banco funcionando!',
      conexao: error ? 'erro' : 'sucesso',
      erro: error?.message || null
    });
  } catch (error) {
    res.json({ 
      message: 'Erro capturado',
      erro: error.message 
    });
  }
});

// Teste OpenAI via GET
app.get('/test-openai', async (req, res) => {
  try {
    const completion = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        {
          role: "user",
          content: "Sou barbeiro e preciso de uma ideia curta para story de s√°bado manh√£"
        }
      ],
      max_tokens: 150
    });

    res.json({
      message: 'OpenAI funcionando!',
      resposta: completion.choices[0].message.content,
      status: 'sucesso'
    });
  } catch (error) {
    res.status(500).json({
      error: 'Erro na OpenAI',
      details: error.message
    });
  }
});

// Teste OpenAI
app.post('/test-gpt', async (req, res) => {
  try {
    const { prompt } = req.body;
    
    const completion = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        {
          role: "user",
          content: prompt || "Diga ol√° em portugu√™s"
        }
      ],
      max_tokens: 100
    });

    res.json({
      message: 'OpenAI funcionando!',
      resposta: completion.choices[0].message.content,
      status: 'sucesso'
    });
  } catch (error) {
    res.status(500).json({
      error: 'Erro na OpenAI',
      details: error.message
    });
  }
});

// Webhook Ticto - INTEGRA√á√ÉO COM PAGAMENTO E SEGURAN√áA
app.post('/webhook/ticto', async (req, res) => {
  try {
    console.log('üí∞ Webhook Ticto recebido:', req.body);
    
    // VALIDAR TOKEN DE SEGURAN√áA TICTO
    const tokenRecebido = req.headers['x-ticto-token'] || req.body.token || req.headers.authorization;
    const tokenEsperado = 'r8DC0BxIsRI2R22zaDcMheURjgzhKXhcRjpa74Lugt39ftl2vir5qtMLwN5zM286B4ApVfYNFHrPylcnSylY7JF9VLF2WJbOvwp4';
    
    if (!tokenRecebido || tokenRecebido !== tokenEsperado) {
      console.error('‚ùå Token inv√°lido ou n√£o fornecido');
      console.error('Token recebido:', tokenRecebido);
      return res.status(401).json({ error: 'Token de autentica√ß√£o inv√°lido' });
    }
    
    console.log('‚úÖ Token Ticto validado com sucesso');
    
    const { email, nome, valor, status, customer, phone } = req.body;
    
    // Extrair telefone do formato da Ticto
    let telefone = null;
    
    if (req.body.telefone) {
      // Formato direto
      telefone = req.body.telefone;
    } else if (phone && phone.number) {
      // Formato da Ticto: phone: { ddd: "999", ddi: "+55", number: "99568246" }
      telefone = `55${phone.ddd}${phone.number}`;
    } else if (customer && customer.phone) {
      // Outro formato poss√≠vel
      telefone = customer.phone;
    }
    
    console.log('üìû Telefone extra√≠do:', telefone);
    
    if (!telefone) {
      console.error('‚ùå Telefone n√£o encontrado no webhook Ticto');
      console.error('Dados recebidos:', JSON.stringify(req.body, null, 2));
      return res.status(400).json({ error: 'Telefone obrigat√≥rio' });
    }
    
    // Verificar se o pagamento foi aprovado
    if (status !== 'approved' && status !== 'paid') {
      console.log(`‚è≥ Pagamento pendente ou rejeitado. Status: ${status}`);
      return res.status(200).json({ 
        status: 'received',
        message: 'Aguardando confirma√ß√£o do pagamento'
      });
    }
    
    // Ajustar n√∫mero se necess√°rio
    let telefoneAjustado = telefone;
    if (telefone.length === 12 && telefone.startsWith('5562')) {
      telefoneAjustado = telefone.substr(0, 4) + '9' + telefone.substr(4);
    }
    
    console.log(`üí≥ Pagamento APROVADO para: ${telefoneAjustado}`);
    console.log(`üí∞ Valor: R$ ${valor}`);
    
    // Verificar se usu√°rio j√° existe
    let usuario = await buscarUsuario(telefoneAjustado);
    
    if (usuario) {
      // Usu√°rio j√° existe - atualizar status de pagamento
      await supabase.from('usuarios')
        .update({ 
          status: 'pago',
          email: email,
          data_expiracao: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 dias
          data_pagamento: new Date(),
          valor_pago: valor
        })
        .eq('telefone', telefoneAjustado);
      
      console.log('‚úÖ Usu√°rio existente atualizado para status PAGO');
    } else {
      // Usu√°rio novo - criar no banco
      await supabase.from('usuarios').insert({
        telefone: telefoneAjustado,
        email: email,
        status: 'pago',
        created_at: new Date(),
        data_expiracao: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 dias
        data_pagamento: new Date(),
        valor_pago: valor
      });
      
      console.log('‚úÖ Novo usu√°rio criado com status PAGO');
    }
    
    // Enviar mensagem de boas-vindas
    const mensagemBoasVindas = `üéâ *Ol√°! Eu sou o Luke Stories!*

Seu assistente pessoal para criar textos e ideias que v√£o te ajudar a gravar conte√∫dos incr√≠veis e fazer sua imagem pessoal e empresa crescerem! üöÄ

üìã *ANTES DE COME√áAR:*
Preciso de algumas informa√ß√µes importantes:

üîπ *Como gostaria de ser chamado(a)?*
üîπ *Qual sua profiss√£o e especialidade?*
üîπ *Que servi√ßos voc√™ oferece?*
üîπ *Tem empresa/neg√≥cio? Qual o nome?*

üì± *COMO USAR O LUKE STORIES:*

üè† *Em casa:* "Preciso de um texto pra gravar aqui em casa agora, de forma animada e motivacional"

üõçÔ∏è *No shopping:* "Estou no shopping comprando um rel√≥gio, quero uma ideia curta e espont√¢nea"

üí° *Para dicas:* "Quero gravar uma dica sobre [seu assunto]"

‚ú® *Pode mandar por √ÅUDIO ou TEXTO* - eu entendo tudo!

Vamos come√ßar? Me mande suas informa√ß√µes! üòä`;

    // Enviar via Z-API
    const ZAPI_URL = `https://api.z-api.io/instances/${process.env.ZAPI_INSTANCE}/token/${process.env.ZAPI_TOKEN}`;
    
    await axios.post(`${ZAPI_URL}/send-text`, {
      phone: telefoneAjustado,
      message: mensagemBoasVindas
    }, {
      headers: {
        'Client-Token': process.env.ZAPI_CLIENT_TOKEN
      }
    });
    
    console.log('‚úÖ Mensagem de boas-vindas enviada para:', telefoneAjustado);
    
    res.status(200).json({ 
      status: 'success',
      message: 'Usu√°rio ativado e mensagem enviada'
    });
    
  } catch (error) {
    console.error('‚ùå Erro no webhook Ticto:', error);
    res.status(500).json({ error: error.message });
  }
});

// Webhook Z-API - VERS√ÉO COM MEM√ìRIA INTELIGENTE
app.post('/webhook/zapi', async (req, res) => {
  try {
    console.log('üîî === WEBHOOK Z-API RECEBIDO ===');
    console.log('üì± Body:', JSON.stringify(req.body, null, 2));
    
    const webhook = req.body;
    
    // Z-API formato: verificar se √© mensagem recebida
    if (!webhook.fromMe && webhook.phone) {
      let telefone = webhook.phone;
      
      console.log(`üìû Telefone original: ${telefone}`);
      
      // Ajustar n√∫mero adicionando 9 se necess√°rio
      if (telefone.length === 12 && telefone.startsWith('5562')) {
        telefone = telefone.substr(0, 4) + '9' + telefone.substr(4);
        console.log(`üìû Telefone ajustado: ${telefone}`);
      }
      
      let mensagem = '';
      let resposta = '';
      
      // Verificar se √© √°udio ou texto
      if (webhook.audio?.audioUrl) {
        console.log('üéµ √ÅUDIO RECEBIDO!');
        console.log('üéµ URL:', webhook.audio.audioUrl);
        console.log('üéµ Dura√ß√£o:', webhook.audio.seconds, 'segundos');
        
        // Processar √°udio para texto
        const textoTranscrito = await processarAudio(webhook.audio.audioUrl);
        
        if (textoTranscrito) {
          mensagem = textoTranscrito;
          console.log(`üí¨ √Åudio transcrito: "${mensagem}"`);
        } else {
          mensagem = 'N√£o consegui entender o √°udio. Pode digitar ou mandar outro √°udio?';
          console.log('‚ùå Falha na transcri√ß√£o');
        }
      } else {
        mensagem = webhook.text?.message || 'Mensagem sem texto';
      }

      console.log(`üí¨ Mensagem recebida: "${mensagem}"`);
      
      // SISTEMA DE CONVERSA POR ETAPAS
      console.log('üß† Verificando se usu√°rio existe...');
      resposta = await processarConversaEtapas(telefone, mensagem);
      
      console.log('‚úÖ Resposta preparada, enviando...');
      console.log('üì§ Enviando resposta via Z-API...');
      
      // Enviar resposta
      const ZAPI_URL = `https://api.z-api.io/instances/${process.env.ZAPI_INSTANCE}/token/${process.env.ZAPI_TOKEN}`;
      
      try {
        const response = await axios.post(`${ZAPI_URL}/send-text`, {
          phone: telefone,
          message: resposta
        }, {
          headers: {
            'Client-Token': process.env.ZAPI_CLIENT_TOKEN
          }
        });
        
        console.log('‚úÖ SUCESSO! Mensagem enviada:', response.data);
      } catch (apiError) {
        console.error('‚ùå Erro Z-API:', apiError.response?.data || apiError.message);
        console.error('‚ùå Status Code:', apiError.response?.status);
        console.error('‚ùå Response Headers:', apiError.response?.headers);
      }
    } else {
      console.log('üö´ Mensagem ignorada (fromMe ou sem phone)');
    }
    
    res.status(200).json({ status: 'processed' });
  } catch (error) {
    console.error('üí• Erro geral:', error);
    res.status(500).json({ error: error.message });
  }
});

app.listen(PORT, () => {
  console.log(`üöÄ Servidor rodando na porta ${PORT}`);
  console.log('üì± Webhook Z-API: /webhook/zapi');
  console.log('üí∞ Webhook Ticto: /webhook/ticto');
  console.log('‚úÖ Supabase configurado!');
  console.log('ü§ñ OpenAI configurado!');
  console.log('üî• BOT PRONTO PARA FUNCIONAR!');
});
